import sys
from random import randint
from blockTree import *
from leaderElection import LeaderElection
from pacemaker import Pacemaker
from mempool import Mempool
from ledger import Ledger
from safety import Safety
from hashing import Hashing
TIMEOUT = 3
N = 3

def init_config():
	config = {
		'window_size': 1,
		'exclude_size': 1,
		'seed':"grabage",
		'f' : 1
	}
	return config

class Validator(process):

	def setup(node_id, validators_list): 
		self.node_id = node_id
		self.validators_list = validators_list

	def run():
		self.config = init_config()
		self.file_path = "./ledger_map"

		self.ledger = Ledger(file_path)
		self.mempool = Mempool()
		self.block_tree = BlockTree(0, 0, 0, self.ledger, self.mempool, self.node_id)
		self.hashing = Hashing()

		self.safety = Safety("", [], self.block_tree, self.ledger)
		

		self.pacemaker = Pacemaker(self.block_tree, self.config)
		self.leader_election = LeaderElection(self.validators_list, self.config['window_size'], self.config['exclude_size'], self.config['seed'], self.ledger, self.pacemaker)	

		while not received(('done',)):
			# if await(received((msgType, 5))):
			print("round restarted")
			self.round_done = False
			if await(self.round_done):
				pass
			elif timeout(TIMEOUT):
				if self.mempool.pending_count > 0:
					self.local_timeout_round()

	def receive(msg= (msgType, obj)):
		# output(msgType, obj)

		if msgType == "proposal_event":
			print("PROPASAL TIMEOUT MESSAGE", obj)
			self.process_proposal_msg(obj)

		elif msgType == "vote_event":
			print("VOTE TIMEOUT MESSAGE", obj)
			self.process_vote_msg(obj)

		elif msgType == "timeout_event":
			# print("RECEIVE TIMEOUT MESSAGE", obj.tmo_info.round, obj.tmo_info.high_qc.vote_info, obj.last_round_tc, obj.high_commit_qc.vote_info)
			self.process_timeout_msg(obj)

		elif msgType == "request":
			self.mempool.insert(obj)


	def process_certificate_qc(qc):
		self.block_tree.process_qc(qc, self.node_id)
		self.leader_election.update_leaders(qc)
		self.advance_round_qc(qc)

	def process_proposal_msg(P):
		process_certificate_qc(P.block.qc)
		process_certificate_qc(P.high_commit_qc)
		self.advance_round_tc(P.last_round_tc)
		round = self.pacemaker.current_round
		leader = self.leader_election.get_leader(round)

		if P.block.round != round or P.sender != leader or P.block.author != leader:
			return

		self.block_tree.execute_and_insert(P.block) # Adds a new speculative state to the Ledger
		vote_msg = self.safety.make_vote(P, P.block, P.last_round_tc, self.node_id)
		if vote_msg is not None:
			l = self.leader_election.get_leader(round + 1)
			#send vote_msg to leader_election.get_leader(current_round + 1)
			send(('vote_event', vote_msg), to=self.validators_list[l])

	def process_timeout_msg(M):
		process_certificate_qc(M.tmo_info.high_qc)
		process_certificate_qc(M.high_commit_qc)
		self.advance_round_tc(M.last_round_tc)
		tc = self.process_remote_timeout(M)
		if tc is not None:
			self.advance_round_tc(tc)
			process_new_round_event(tc)

	def process_vote_msg(M):
		qc = self.block_tree.process_vote(M, self.node_id)
		if qc is not None:
			process_certificate_qc(qc)
			process_new_round_event(None)

	def process_new_round_event(last_tc):
		if self.node_id == self.leader_election.get_leader(self.pacemaker.current_round):
			# Leader code: generate proposal.
			b = self.block_tree.generate_block(self.mempool.get_transactions(), self.pacemaker.current_round)
			#broadcast ProposalMsg; last tc; block_tree:high commit qci
			send(('proposal_event', ProposalMsg(b, last_tc, self.block_tree.high_commit_qc, self.node_id)), to=self.validators_list)

	def local_timeout_round():
		tmo_info = self.safety.make_timeout(self.pacemaker.current_round, self.block_tree.high_qc, self.pacemaker.last_round_tc, self.node_id)


		send(('timeout_event', TimeoutMsg(tmo_info, self.pacemaker.last_round_tc, self.block_tree.high_commit_qc)), to=self.validators_list)

	def start_timer(new_round):
		self.pacemaker.current_round = new_round
		self.round_done = True

	def advance_round_tc(tc):
		if tc is None or tc.round < self.pacemaker.current_round:
			return False
		self.pacemaker.last_round_tc = tc
		self.start_timer(tc.round + 1)
		return True

	def advance_round_qc(qc):
		if qc.vote_info.round < self.pacemaker.current_round:
			return False
		self.pacemaker.last_round_tc = None
		self.start_timer(qc.vote_info.round + 1)
		return True

	def process_remote_timeout(timeout):
		timeout_info = timeout.tmo_info
		
		if timeout_info.round < self.pacemaker.current_round:
			return None
			
		# print("pm 1")
		if timeout_info.round not in self.pacemaker.pending_timeouts.keys():
			self.pacemaker.pending_timeouts[timeout_info.round] = [timeout_info]
		else:
			tmo_senders = [t.sender for t in self.pacemaker.pending_timeouts[timeout_info.round] if t is not None]
			if timeout_info.sender not in tmo_senders:
				self.pacemaker.pending_timeouts[timeout_info.round].append(timeout_info)
        # print("pm 2")
		
		tmo_senders = [t.sender for t in self.pacemaker.pending_timeouts[timeout_info.round] if t is not None]

        # print("pm 3")
		
		if len(tmo_senders) == self.pacemaker.config['f'] + 1:
			self.local_timeout_round()
			
		if len(tmo_senders) == 2*self.pacemaker.config['f'] + 1:
			return TC(
				timeout_info.round,
				[t.high_qc.vote_info.round for t in self.pacemaker.pending_timeouts[timeout_info.round]],
				[t.signature for t in self.pacemaker.pending_timeouts[timeout_info.round]]
			)
		
		return None

		

class Client(process):

	def setup(node_id, validators_list):
		self.node_id = node_id
		self.validators_list = validators_list

	def run():
		for i in range(2):
			obj = {
				'transaction_id' : str(self.node_id*2 + i),
				'node_id' : self.node_id
			}

			send(('request', obj), to=self.validators_list)
		pass



def main():
	
	num_servers = N
	num_clients = N

	clients = new(Client, num = num_clients)
	validators = new(Validator, num= num_servers)
	#Can add new variables to setup if necessary
	for i, validator in enumerate(validators):
		setup(validator, args=(i, list(validators)))

	for i, client in enumerate(clients):
		setup(client, args=(i, list(validators)))
	start(validators)
	start(clients)
