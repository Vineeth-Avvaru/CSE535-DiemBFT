import sys
from random import randint
import BlockTree
import LeaderElection
import Pacemaker
import Mempool
import Ledger
import Safety
import Hashing
TIMEOUT = 1
N = 10

def init_config():
	config = {}
	return config

class Validator(process):
	def __init__():
		#TODO : initialize classes appropriately

		self.config = init_config()
		self.file_path = "./ledger_map"

    	self.ledger = Ledger(file_path=file_path)
    	self.mempool = Mempool()
		self.block_tree = BlockTree(0, 0, 0, ledger, mempool)
		self.hashing = Hashing()

		self.safety = Safety("", [], self.block_tree, self.ledger)
		

		self.pacemaker = Pacemaker(self.block_tree, self.config)


		

	def setup(node_id, validators_list): 
		pass

	def run():
		self.leader_election = LeaderElection(self.validators_list, self.config.window_size, self.config.exclude_size, self.config.seed, self.ledger, self.pacemaker)	

		while not received(('done',)):
			if await(received((msgType, 5), from_= b)):
				pass
			# elif await(received(('vote_event', 5), from_= b)):
			# 	pass
			# elif await(some(received(('timeout_event', 5), from_= b))):
			# 	pass
			elif timeout(TIMEOUT):
				# pacemaker.local_timeout_round()
				debug("local timeout")




	def receive(msg= (msgType, obj), from_= b):
		print(n) 
		output("Received Vote event from Node")

		if msgType == "local_timeout":
			self.local_timeout_round()

		elif msgType == "proposal_event":
			self.process_proposal_msg(obj)

		elif msgType == "vote_event":
			self.process_vote_msg(obj)

		elif msgType == "timeout_event":
			self.process_timeout_msg(obj)

		elif msgType == "request":
			self.mempool.insert(obj)


	def process_certificate_qc(self, qc):
		block_tree.process_qc(qc, self.node_id)
		leader_election.update_leaders(qc)
		pacemaker.advance_round(qc.vote_info.round)

	def process_proposal_msg(self, P)
		process_certificate_qc(P.block.qc)
		process_certificate_qc(P.high_commit_qc)

		pacemaker.advance_round_tc(P.last_round_tc)

		round = pacemaker.current_round
		leader = leader_election.get_leader(current_round)

		if P.block.round != round or P.sender != leader or P.block.author != leader:
			return

		block_tree.execute_and_insert(P) # Adds a new speculative state to the Ledger
		vote_msg = Safety.make_vote(P.block, P.last_round_tc)
		if vote_msg not None:
			# TODO: implement sending vote message
			# pass
			#send vote_msg to leader_election.get_leader(current_round + 1)

	def process_timeout_msg(self, M):
		process_certificate_qc(M.tmo_info.high_qc)
		process_certificate_qc(M.high_commit_qc)
		pacemaker.advance_round_tc(M.last_round_tc)
		tc = pacemaker.process_remote_timeout(M)
		if tc not None:
			pacemaker.advance_round(tc)
			process_new_round_event(tc)

	def process_vote_msg(self, M):
		qc = block_tree.process_vote(M, self.node_id)
		if qc not None:
			process_certificate_qc(qc)
			process_new_round_event(None)

	def process_new_round_event(self, last_tc):
		if u == leader_election.get_leader(pacemaker.current_round):
			# Leader code: generate proposal.
			b = block_tree.generate_block(mempool.get_transactions(),
			pacemaker.current round)
			#Todo: broadcast proposal messsage
			#broadcast ProposalMsghb; last tc; block_tree:high commit qci

	def local_timeout_round(self):
		pass

lass Validator(process):
	def __init__():
		pass
		

	def setup(node_id, validators_list): 
		pass

	def run():
		for i in range(5):
			obj = {
				transaction_id : str(self.node_id*5 + i),
				node_id : self.node_id
			}

			send(('request', obj), to=validators_list)



def main():
	
	num_servers = N
	num_clients = N

	clients = new(Client, num = num_clients)
	validators = new(Validator, num= num_servers)

	#Can add new variables to setup if necessary
	for i, validator in enumerate(validators):
    	setup(validator, (i, list(validators)))

    for i, client in enumerate(clients):
    	setup(client, (i, list(validators)))

	start(validators)
	start(clients)
